# query_first_ring.py
"""
Quick module to query the first ring that covers a specific terminal for a root,
using the tr_coverage_report.csv generated by analyze_tr_coverage.py.
Requires loading the graph G for waypoint-to-index mapping.
"""

import ast
import pandas as pd
from generate_reference_data import generate_reference_data
from generate_graph_data import generate_graph_data
import data_store as ds
from api_common import set_logger


def load_graph_and_data(config, kwargs):
    """Load G and return node_key_by_index inv mapping."""
    data = generate_reference_data(
        config, kwargs["prices"], kwargs["modifiers"], kwargs["min_lodging"], kwargs["grind_taken_list"]
    )
    generate_graph_data(data)
    G = data["G"]
    inv = G.attrs["node_key_by_index"].inv
    return G, inv


def query_first_ring(
    root_waypoint: int, terminal_waypoint: int, csv_path: str = "tr_coverage_report.csv"
) -> int | None:
    """
    Find the smallest ring_index (0-based) where the terminal is first covered for the root.

    Args:
        root_waypoint: Waypoint key for root (int).
        terminal_waypoint: Waypoint key for terminal (int).
        csv_path: Path to tr_coverage_report.csv.

    Returns:
        ring_index (int) or None if not found.
    """
    # Load CSV
    df = pd.read_csv(csv_path)

    # Filter per-ring rows for this root (exclude bins)
    root_rows = df[
        (df["root"] == root_waypoint)
        & (~df["ring_index"].astype(str).str.startswith("bin_"))  # Exclude bins first
        & (pd.to_numeric(df["ring_index"], errors="coerce") >= 0)  # Safe numeric >=0
    ].copy()

    if root_rows.empty:
        return None

    root_rows = root_rows.sort_values("ring_index").reset_index(drop=True)

    # Map waypoints to indices (load G minimally; assumes run after analysis)
    # TODO: In practice, load once outside; here for standalone
    # Common config
    config = {}
    config["name"] = "Empire"
    config["budget"] = 50  # N/A
    config["top_n"] = 324  # all prizes
    config["nearest_n"] = 30  # all roots
    config["max_waypoint_ub"] = 30  # N/A
    config["prune_prizes"] = False
    config["solver"] = {}  # N/A

    config["logger"] = {"level": "INFO", "format": "<level>{message}</level>"}
    set_logger(config)

    set_logger(config)
    kwargs = {  # Minimal for load
        "prices": ds.read_json("en_lta_prices.json")["effectivePrices"],
        "modifiers": {},
        "grind_taken_list": [],
        "min_lodging": ds.read_json("lodging_specifications.json")["min"],
    }
    _, inv = load_graph_and_data(config, kwargs)

    root_idx = inv[root_waypoint]
    t_idx = inv.get(terminal_waypoint)
    if t_idx is None:
        return None  # Terminal not in graph

    # Find first ring where t_idx in cumulative hull_nodes
    for idx, row in root_rows.iterrows():
        hull_nodes_str = row["hull_nodes"]
        hull_nodes = ast.literal_eval(hull_nodes_str)
        if t_idx in hull_nodes:
            print(
                f"Details for ring {int(row['ring_index'])} (root {root_waypoint}, term {terminal_waypoint}):"
            )
            print(row.to_dict())  # Or row.to_string() for formatted
            return int(row["ring_index"])

    return None  # Not covered


if __name__ == "__main__":
    # Example usage
    root_wp = 601  # e.g., root waypoint
    # term_wp = 910  # e.g., terminal waypoint
    term_wp = 912  # e.g., terminal waypoint
    first_ring = query_first_ring(root_wp, term_wp)
    print(f"Terminal {term_wp} first covered in ring {first_ring} for root {root_wp}")
