# visualize_value_basins.py

# visualize_solution.py

"""
Visualizes the solution graph generated by the Steiner Forest solver
on the BDO map.

Edit the 'subgraph' entries at the bottom of the file.
"""

from pathlib import Path
from typing import Any
import branca
import folium
import webbrowser
import os
import tempfile
import folium.map
from loguru import logger
import rustworkx as rx
from folium.plugins import FeatureGroupSubGroup, GroupedLayerControl

import data_store as ds
from api_common import set_logger
from generate_reference_data import generate_reference_data
from generate_graph_data import generate_graph_data


TILE_SCALE = 12800

MARKER_COLORS = [
    "blue",
    "gray",
    "lightred",
    "purple",
    "red",
    "lightblue",
    "lightgray",
    "black",
    # "white",
    "lightgreen",
    "green",
    "darkred",
    "darkblue",
    "cadetblue",
    "pink",
    "darkgreen",
    "darkpurple",
    "beige",
    "orange",
]

# Color Constants
MAIN_GRAPH_EDGE_COLOR = "darkturquoise"
SUBGRAPH_EDGE_COLOR = "yellow"
SUBGRAPH_OPTIMAL_EDGE_COLOR = "red"
MAIN_OPTIMAL_EDGE_COLOR = "yellow"
BASE_TOWN_COLOR = "green"
REGULAR_NODE_COLOR = "yellow"
SUPER_ROOT_COLOR = "red"

# Line Thicknesses
MAIN_GRAPH_EDGE_WEIGHT = 1
SUBGRAPH_EDGE_WEIGHT = 6
MAIN_OPTIMAL_EDGE_WEIGHT = 6
SUBGRAPH_OPTIMAL_EDGE_WEIGHT = 2

min_lodging = {
    "Velia": 0,
    "Heidel": 0,
    "Glish": 0,
    "Calpheon City": 0,
    "Olvia": 0,
    "Keplan": 0,
    "Port Epheria": 0,
    "Trent": 0,
    "Iliya Island": 0,
    "Altinova": 0,
    "Tarif": 0,
    "Valencia City": 0,
    "Shakatu": 0,
    "Sand Grain Bazaar": 0,
    "Ancado Inner Harbor": 0,
    "Arehaza": 0,
    "Old Wisdom Tree": 0,
    "Grána": 0,
    "Duvencrune": 0,
    "O'draxxia": 0,
    "Eilton": 0,
    "Dalbeol Village": 0,
    "Nampo's Moodle Village": 0,
    "Nopsae's Byeot County": 0,
    "Asparkan": 0,
    "Muzgar": 0,
    "Yukjo Street": 0,
    "Godu Village": 0,
    "Bukpo": 0,
    "Hakinza Sanctuary": 0,
}
max_lodging = {
    "Velia": 7,
    "Heidel": 7,
    "Glish": 6,
    "Calpheon City": 7,
    "Olvia": 6,
    "Keplan": 6,
    "Port Epheria": 5,
    "Trent": 6,
    "Iliya Island": 0,
    "Altinova": 8,
    "Tarif": 6,
    "Valencia City": 7,
    "Shakatu": 6,
    "Sand Grain Bazaar": 5,
    "Ancado Inner Harbor": 0,
    "Arehaza": 5,
    "Old Wisdom Tree": 6,
    "Grána": 7,
    "Duvencrune": 7,
    "O'draxxia": 9,
    "Eilton": 6,
    "Dalbeol Village": 6,
    "Nampo's Moodle Village": 6,
    "Nopsae's Byeot County": 6,
    "Asparkan": 5,
    "Muzgar": 5,
    "Yukjo Street": 5,
    "Godu Village": 6,
    "Bukpo": 6,
    "Hakinza Sanctuary": 7,
}
lodging_specifications = {
    "Velia": {"bonus": 0, "reserved": 0, "prepaid": 0, "bonus_ub": 7},
    "Heidel": {"bonus": 0, "reserved": 0, "prepaid": 0, "bonus_ub": 7},
    "Glish": {"bonus": 0, "reserved": 0, "prepaid": 0, "bonus_ub": 6},
    "Calpheon City": {"bonus": 0, "reserved": 0, "prepaid": 0, "bonus_ub": 7},
    "Olvia": {"bonus": 0, "reserved": 0, "prepaid": 0, "bonus_ub": 6},
    "Keplan": {"bonus": 0, "reserved": 0, "prepaid": 0, "bonus_ub": 6},
    "Port Epheria": {"bonus": 0, "reserved": 0, "prepaid": 0, "bonus_ub": 5},
    "Trent": {"bonus": 0, "reserved": 0, "prepaid": 0, "bonus_ub": 6},
    "Iliya Island": {"bonus": 0, "reserved": 0, "prepaid": 0, "bonus_ub": 0},
    "Altinova": {"bonus": 0, "reserved": 0, "prepaid": 0, "bonus_ub": 8},
    "Tarif": {"bonus": 0, "reserved": 0, "prepaid": 0, "bonus_ub": 6},
    "Valencia City": {"bonus": 0, "reserved": 0, "prepaid": 0, "bonus_ub": 7},
    "Shakatu": {"bonus": 0, "reserved": 0, "prepaid": 0, "bonus_ub": 6},
    "Sand Grain Bazaar": {"bonus": 0, "reserved": 0, "prepaid": 0, "bonus_ub": 5},
    "Ancado Inner Harbor": {"bonus": 0, "reserved": 0, "prepaid": 0, "bonus_ub": 0},
    "Arehaza": {"bonus": 0, "reserved": 0, "prepaid": 0, "bonus_ub": 5},
    "Old Wisdom Tree": {"bonus": 0, "reserved": 0, "prepaid": 0, "bonus_ub": 6},
    "Grána": {"bonus": 0, "reserved": 0, "prepaid": 0, "bonus_ub": 7},
    "Duvencrune": {"bonus": 0, "reserved": 0, "prepaid": 0, "bonus_ub": 7},
    "O'draxxia": {"bonus": 0, "reserved": 0, "prepaid": 0, "bonus_ub": 9},
    "Eilton": {"bonus": 0, "reserved": 0, "prepaid": 0, "bonus_ub": 6},
    "Dalbeol Village": {"bonus": 0, "reserved": 0, "prepaid": 0, "bonus_ub": 6},
    "Nampo's Moodle Village": {"bonus": 0, "reserved": 0, "prepaid": 0, "bonus_ub": 6},
    "Nopsae's Byeot County": {"bonus": 0, "reserved": 0, "prepaid": 0, "bonus_ub": 6},
    "Asparkan": {"bonus": 0, "reserved": 0, "prepaid": 0, "bonus_ub": 5},
    "Muzgar": {"bonus": 0, "reserved": 0, "prepaid": 0, "bonus_ub": 5},
    "Yukjo Street": {"bonus": 0, "reserved": 0, "prepaid": 0, "bonus_ub": 5},
    "Godu Village": {"bonus": 0, "reserved": 0, "prepaid": 0, "bonus_ub": 6},
    "Bukpo": {"bonus": 0, "reserved": 0, "prepaid": 0, "bonus_ub": 6},
    "Hakinza Sanctuary": {"bonus": 0, "reserved": 0, "prepaid": 0, "bonus_ub": 7},
}


def visualize_basin_graph(data: dict[str, Any]):
    """
    Visualizes the game map with root indicators for each terminal valuing the root at rank 1.

    Args:
        graph_data containing the graph:G (rx.PyGraph) in the attribute "solver_graph"
    """

    G = data["solver_graph"]

    # This is the main map which provides the coordinate system for location and ui controls.
    m = folium.Map(
        crs="Simple",  # Don't change
        location=[0, 0],  # Don't change
        zoom_start=2,  # Don't change
        zoom_snap=0.25,
        tiles=None,
    )

    # The tiles need to be a pane fixed at the bottom layer for proper drawing layers.
    tile_pane = folium.map.CustomPane("tile_pane", z_index=1)
    m.add_child(tile_pane)

    # Don't change, the zoom levels are pretty critical on these tiles.
    tiles = os.path.join(ds.path(), "maptiles", "{z}", "{x}_{y}.webp")
    tile_layer = folium.TileLayer(
        name="BDO Router",
        attr="Map Tiles @ BDO",
        min_zoom=1,
        max_zoom=7,
        no_wrap=True,
        pane="tile_pane",
        show=True,
        tiles=tiles,
    )
    tile_layer.add_to(m)

    # These Feature Groups allow control of the UI elements and are used for the
    # z-order of the layers when we set the keep_in_front setting below.
    # There is a layer for 'all' and a layer for each root.
    # The layer for each root is nested under the 'all' layer.

    # Basic dull background layer of all nodes and edges.
    fg_all_nodes = folium.FeatureGroup(name="All Nodes", show=True)
    fg_main_graph_edges = folium.FeatureGroup(name="Main Graph Edges", show=True)
    add_node_markers_from_graph(fg_all_nodes, G)
    add_edges_from_graph(
        fg_main_graph_edges,
        G,
        color=MAIN_GRAPH_EDGE_COLOR,
        weight=MAIN_GRAPH_EDGE_WEIGHT,
    )

    # Terminal sets toggling is a bit trickier, see the called function
    # for more details but in short we have a master and independent controls.
    terminal_set_feature_groups, fg_terminal_sets_master = add_terminal_sets_markers(m, G)
    assert fg_terminal_sets_master is not None

    # All Feature Groups are added to the map except the terminal groups which
    # got added in the add_terminal_sets_markers function.
    fg_all_nodes.add_to(m)
    fg_main_graph_edges.add_to(m)

    # NOTE: The keep_in_front order is critical!
    m.keep_in_front(
        fg_main_graph_edges,
        fg_all_nodes,
        fg_terminal_sets_master,
        *terminal_set_feature_groups.values(),
    )

    # Grouped Layer Control for everything except Terminal Sets which is
    # handled below as its own LayerControl.
    group_layer_control = GroupedLayerControl(
        groups={"Base": [fg_all_nodes, fg_main_graph_edges]},
        exclusive_groups=False,
        collapsed=False,
    )

    # Add the LayerControl after the tile layer
    folium.LayerControl(collapsed=False).add_to(m)
    group_layer_control.add_to(m)

    # Add the graph stats to the map
    stats_html = f"""
        <div style="position:absolute; z-index:100000; left:10px; top:10px;
                    background-color:white; padding:10px; border:1px solid black;">
            <h2>Graph/Solution Stats</h2>
            <p>Main Graph Nodes: {len(G.nodes())}</p>
            <p>Main Graph Edges: {len(G.edge_list())}</p>
        </div>"""
    root = m.get_root()
    if isinstance(root, branca.element.Figure):  # (mostly for Pylance)
        root.html.add_child(folium.Element(stats_html))

    tmp_dir = tempfile.gettempdir()
    map_file = os.path.join(tmp_dir, "bdo_map.html")
    m.save(map_file)
    print(f"Map saved to {map_file}. Opening in your browser...")
    webbrowser.open("file://" + map_file)


def add_edges_from_graph(
    fg: folium.FeatureGroup,
    graph: rx.PyGraph | rx.PyDiGraph,
    color: str | None = None,
    weight: float = 0.75,
):
    """Add edges from the graph to the map."""
    for u_index, v_index in graph.edge_list():
        # Only include one edge of a bidirectional connection.
        if u_index > v_index and not graph.has_edge(v_index, u_index):
            continue

        u_node = graph[u_index]
        v_node = graph[v_index]
        if u_node["waypoint_key"] == 99999 or v_node["waypoint_key"] == 99999:
            continue

        start = u_node["position"]
        end = v_node["position"]

        start_lat = start["z"] / TILE_SCALE
        start_lng = start["x"] / TILE_SCALE
        end_lat = end["z"] / TILE_SCALE
        end_lng = end["x"] / TILE_SCALE

        folium.PolyLine(
            locations=[
                (start_lat, start_lng),
                (end_lat, end_lng),
            ],
            color=color,
            weight=weight,
            opacity=1,
            popup=f"Edge: {u_node['waypoint_key']} - {v_node['waypoint_key']}",
            tooltip=f"Edge: {u_node['waypoint_key']} - {v_node['waypoint_key']}",
            **{"interactive": True, "bubblingMouseEvents": True},
        ).add_to(fg)


def add_node_markers_from_graph(fg: folium.FeatureGroup, graph: rx.PyGraph | rx.PyDiGraph):
    """Add markers for each node in the main graph."""
    for node in graph.nodes():
        node_color = None  # Reset the color for each node
        node_key = node["waypoint_key"]
        cost = node["need_exploration_point"]

        lng = node["position"]["x"] / TILE_SCALE  # Scaled coordinates
        lat = node["position"]["z"] / TILE_SCALE  # Scaled coordinates

        popup_text = f"Node Key: {node_key}, Cost: {cost}"

        if node_key == 99999:
            popup_text += " (Super Root)"
            node_color = SUPER_ROOT_COLOR

        if node_color is None:
            if node["is_base_town"]:
                node_color = BASE_TOWN_COLOR
            else:
                node_color = REGULAR_NODE_COLOR

        folium.CircleMarker(
            location=(lat, lng),
            radius=1 if not node["is_base_town"] else 4,
            color=node_color,
            fill=True,
            fill_color=node_color,
            popup=popup_text,
            tooltip=popup_text,
        ).add_to(fg)


def add_terminal_sets_markers(
    m: folium.Map, G: rx.PyGraph | rx.PyDiGraph
) -> tuple[dict[str, FeatureGroupSubGroup], folium.FeatureGroup | None]:
    """Add terminal value indicator sets using FeatureGroupSubGroup for hierarchical toggling."""

    # For each root node get all terminals where the root node is rank 1 in the prizes
    terminal_sets = {}
    root_indices = G.attrs["root_indices"]
    terminals = G.attrs["terminals"]
    for root in root_indices:
        rank1_terminals = []
        for terminal in terminals:
            if root == list(G[terminal]["prizes"].keys())[0]:
                rank1_terminals.append(terminal)
        terminal_sets[root] = rank1_terminals

    # As the name indicates, this is the master FeatureGroup for the terminals layer.
    fg_terminal_sets_master = folium.FeatureGroup(name="All Terminal Sets", show=True).add_to(m)
    assert isinstance(fg_terminal_sets_master, folium.FeatureGroup)

    terminal_set_feature_groups = {}

    for color_index, (root, terminal_set) in enumerate(terminal_sets.items()):
        layer_name = f"Terminal Set {chr(65 + color_index)}"
        # FeatureGroupSubGroup nests the terminal set under the master group
        fg_terminal_set = FeatureGroupSubGroup(fg_terminal_sets_master, name=layer_name, show=True).add_to(m)
        terminal_set_feature_groups[layer_name] = fg_terminal_set

        terminal_set_color = MARKER_COLORS[color_index % len(MARKER_COLORS)]

        # Root node marker setup
        root_node = G[root]
        root_lng = root_node["position"]["x"] / TILE_SCALE
        root_lat = root_node["position"]["z"] / TILE_SCALE

        folium.Marker(
            location=(root_lat, root_lng),
            icon=folium.Icon(
                color=terminal_set_color,
                icon=f"{chr(97 + color_index)}",
                prefix="fa",
                extraClasses="fa-border",
            ),
            popup=f"Root Node Key: {root_node['waypoint_key']}, Cost: {root_node['need_exploration_point']}",
            tooltip=f"Root Node Key: {root_node['waypoint_key']}, Cost: {root_node['need_exploration_point']}",
        ).add_to(fg_terminal_set)

        # Terminal node markers setup
        for terminal in terminal_set:
            terminal_node = G[terminal]
            terminal_lng = terminal_node["position"]["x"] / TILE_SCALE
            terminal_lat = terminal_node["position"]["z"] / TILE_SCALE

            folium.Marker(
                location=(terminal_lat, terminal_lng),
                icon=folium.Icon(color=terminal_set_color, icon=f"{chr(97 + color_index)}", prefix="fa"),
                popup=f"Terminal Node Key: {terminal_node['waypoint_key']}, Cost: {terminal_node['need_exploration_point']}",
                tooltip=f"Terminal Node Key: {terminal_node['waypoint_key']}, Cost: {terminal_node['need_exploration_point']}",
            ).add_to(fg_terminal_set)

    return terminal_set_feature_groups, fg_terminal_sets_master


def main():
    # import sys
    # sys.activate_stack_trampoline("perf")

    import datetime
    import json
    import tkinter as tk
    from tkinter import filedialog

    tk_root = tk.Tk()
    tk_root.withdraw()
    file_path = filedialog.askopenfilename()
    prices = json.loads(Path(file_path).read_text(encoding="utf-8"))["effectivePrices"]

    modifiers = {}
    grindTakenList = []
    lodging = min_lodging

    # today = datetime.datetime.now().strftime("%y%m%d_%H%M")
    # logfile = Path(ds.path()).parent.parent.parent.joinpath("zzz_out_new", "logs")
    # workerman_file = Path(ds.path()).parent.parent.parent.joinpath("zzz_out_new", "workerman")

    # Empirical testing (prior to adding the clustering logic) shows that the best parameters are:
    # For < 550 budget:
    #   "do_prune" = True
    #   "do_reduce" = True
    #   "cr_pairs" = True
    #   "prize_scale" = True
    #   "root_cost" = False
    # and for > 550 budget:
    #   "do_prune" = True
    #   "do_reduce" = True
    #   "cr_pairs" = False
    #   "prize_scale" = True
    #   "root_cost" = True

    # Args wont matter for visualizations
    args = {
        "do_prune": True,
        "do_reduce": True,
        "cr_pairs": True,
        "prize_scale": True,
        "root_cost": False,
    }

    config: dict = {
        "name": "EmpireVisualizer",
        "budget": 600,
        "top_n": 6,
        "nearest_n": 7,
        "waypoint_ub": 17,
    }

    data = generate_reference_data(config, prices, modifiers, lodging, grindTakenList)
    graph_data = generate_graph_data(data, args["do_prune"], args["do_reduce"])
    visualize_basin_graph(graph_data)


if __name__ == "__main__":
    config = {}
    config["logger"] = {"level": "DEBUG", "format": "<level>{message}</level>"}
    set_logger(config)
    main()
